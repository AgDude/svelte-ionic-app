{"version":3,"file":"index-861cd15d.js","sources":["../../node_modules/svelte/store/index.mjs","../../node_modules/@sveltech/routify/runtime/helpers.js","../../node_modules/@sveltech/routify/runtime/store.js","../../node_modules/@sveltech/routify/runtime/utils.js","../../node_modules/@sveltech/routify/runtime/Route.svelte","../../node_modules/@sveltech/routify/runtime/navigator.js","../../node_modules/@sveltech/routify/runtime/Router.svelte"],"sourcesContent":["import { safe_not_equal, noop, run_all, is_function } from '../internal';\nexport { get_store_value as get } from '../internal';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe,\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { getContext } from 'svelte'\r\nimport { derived } from 'svelte/store'\r\n\r\nexport const context = {\r\n  subscribe(listener) {\r\n    return getContext('routify').subscribe(listener)\r\n  },\r\n}\r\n\r\n/**\r\n * We have to grab params and leftover from the context and not directly from the store.\r\n * Otherwise the context is updated before the component is destroyed.\r\n **/\r\nexport const params = {\r\n  subscribe(listener) {\r\n    return derived(\r\n      getContext('routify'),\r\n      context => context.route.params\r\n    ).subscribe(listener)\r\n  },\r\n}\r\n\r\nexport const leftover = {\r\n  subscribe(listener) {\r\n    return derived(\r\n      getContext('routify'),\r\n      context => context.route.leftover\r\n    ).subscribe(listener)\r\n  },\r\n}\r\n\r\n/** HELPERS */\r\nexport const url = {\r\n  subscribe(listener) {\r\n    return derived(getContext('routify'), context => context.url).subscribe(\r\n      listener\r\n    )\r\n  },\r\n}\r\n\r\nexport const goto = {\r\n  subscribe(listener) {\r\n    return derived(getContext('routify'), context => context.goto).subscribe(\r\n      listener\r\n    )\r\n  },\r\n}\r\n\r\nexport const isActive = {\r\n  subscribe(listener) {\r\n    return derived(\r\n      getContext('routify'),\r\n      context => context.isActive\r\n    ).subscribe(listener)\r\n  },\r\n}\r\n\r\nexport function _isActive(context, route) {\r\n  const url = _url(context, route)\r\n  return function(path, keepIndex = true) {\r\n    path = url(path, null, keepIndex)\r\n    const currentPath = url(route.path, null, keepIndex)\r\n    const re = new RegExp('^' + path)\r\n    return currentPath.match(re)\r\n  }\r\n}\r\n\r\nexport function _goto(context, route) {\r\n  const url = _url(context, route)\r\n  return function goto(path, params, _static, shallow) {\r\n    const href = url(path, params)\r\n    if (!_static) history.pushState({}, null, href)\r\n    else getContext('routifyupdatepage')(href, shallow)\r\n  }\r\n}\r\n\r\nexport function _url(context, route) {\r\n  return function url(path, params, preserveIndex) {\r\n    path = path || './'\r\n\r\n    if (!preserveIndex) path = path.replace(/index$/, '')\r\n\r\n    if (path.match(/^\\.\\.?\\//)) {\r\n      //RELATIVE PATH\r\n      // get component's dir\r\n      // let dir = context.path.replace(/[^\\/]+$/, '')\r\n      let dir = context.path\r\n      // traverse through parents if needed\r\n      const traverse = path.match(/\\.\\.\\//g) || []\r\n      traverse.forEach(() => {\r\n        dir = dir.replace(/\\/[^\\/]+\\/?$/, '')\r\n      })\r\n\r\n      // strip leading periods and slashes\r\n      path = path.replace(/^[\\.\\/]+/, '')\r\n      dir = dir.replace(/\\/$/, '') + '/'\r\n      path = dir + path\r\n    } else if (path.match(/^\\//)) {\r\n      // ABSOLUTE PATH\r\n    }\r\n\r\n    params = Object.assign({}, route.params, context.params, params)\r\n    for (const [key, value] of Object.entries(params)) {\r\n      path = path.replace(`:${key}`, value)\r\n    }\r\n    return path\r\n  }\r\n}\r\n","import { writable } from 'svelte/store'\r\n\r\nexport const route = writable({})\r\n","const MATCH_PARAM = RegExp(/\\:[^\\/\\()]+/g)\r\n\r\nexport const scrollAncestorsToTop = function(element) {\r\n  if (element && element.dataset.routify !== 'scroll-lock') {\r\n    element.scrollTo(0, 0)\r\n    scrollAncestorsToTop(element.parentElement)\r\n  }\r\n}\r\n\r\nexport const pathToRegex = (str, recursive) => {\r\n  const suffix = recursive ? '' : '/?$' //fallbacks should match recursively\r\n  str = str.replace(/\\/_fallback?$/, '(/|$)')\r\n  str = str.replace(/\\/index$/, '(/index)?') //index files should be matched even if not present in url\r\n  str = '^' + str.replace(MATCH_PARAM, '([^/]+)') + suffix\r\n  return str\r\n}\r\n\r\nexport const pathToParams = string => {\r\n  const matches = string.match(MATCH_PARAM)\r\n  if (matches) return matches.map(str => str.substr(1, str.length - 2))\r\n}\r\n\r\nexport const pathToRank = ({ path, isFallback }) => {\r\n  return !isFallback\r\n    ? 'Z'\r\n    : path\r\n        .split('/')\r\n        .map(str => (str.match(/\\[|\\]/) ? 'A' : 'B'))\r\n        .join('')\r\n}\r\n","<script>\r\n  import { setContext } from 'svelte'\r\n  import * as internals from 'svelte/internal'\r\n  import { demandObject, suppressWarnings } from './scripts.js'\r\n  import { writable } from 'svelte/store'\r\n  import { _url, _goto, _isActive } from './helpers.js'\r\n  import { route } from './store'\r\n  import { scrollAncestorsToTop } from './utils'\r\n\r\n  export let layouts = [],\r\n    scoped = {}\r\n  let scopeToChild,\r\n    props = {},\r\n    parentElement,\r\n    component\r\n  const context = writable({})\r\n  setContext('routify', context)\r\n\r\n  $: [layout, ...remainingLayouts] = layouts\r\n  $: setComponent(layout)\r\n  $: if (!remainingLayouts.length) scrollAncestorsToTop(parentElement)\r\n\r\n  function setParent(el) {\r\n    parentElement = el.parentElement\r\n  }\r\n\r\n  function updateContext(layout) {\r\n    context.set({\r\n      route: $route,\r\n      path: layout.path,\r\n      url: _url(layout, $route),\r\n      goto: _goto(layout, $route),\r\n      isActive: _isActive(layout, $route),\r\n    })\r\n  }\r\n\r\n  async function setComponent(layout) {\r\n    // We want component and context to be synchronized\r\n    component = await layout.component()\r\n    updateContext(layout)\r\n  }\r\n</script>\r\n\r\n{#if component}\r\n  <svelte:component\r\n    this={component}\r\n    let:scoped={scopeToChild}\r\n    {scoped}\r\n    {...layout.param}>\r\n    {#if remainingLayouts.length}\r\n      <svelte:self\r\n        layouts={remainingLayouts}\r\n        scoped={{ ...scoped, ...scopeToChild }} />\r\n    {/if}\r\n  </svelte:component>\r\n{/if}\r\n\r\n<!-- get the parent element for scroll functionality -->\r\n{#if !parentElement}\r\n  <span use:setParent />\r\n{/if}\r\n","import * as store from './store'\r\n\r\nexport default function(routes, cb) {\r\n  // create events for pushState and replaceState\r\n  ;['pushState', 'replaceState'].forEach(eventName => {\r\n    const fn = history[eventName]\r\n    history[eventName] = function(state, title, url) {\r\n      const event = Object.assign(\r\n        new Event(eventName.toLowerCase(), { state, title, url })\r\n      )\r\n      Object.assign(event, { state, title, url })\r\n\r\n      fn.apply(this, [state, title, url])\r\n      return dispatchEvent(event)\r\n    }\r\n  })\r\n\r\n  function updatePage(url, shallow) {\r\n    const currentUrl = window.location.pathname\r\n    url = url || currentUrl\r\n\r\n    const route = urlToRoute(url, routes)\r\n    const currentRoute = shallow && urlToRoute(currentUrl, routes)\r\n    const contextRoute = currentRoute || route\r\n    const layouts = [...contextRoute.layouts, route]\r\n\r\n    //set the route in the store\r\n    store.route.set(route)\r\n\r\n    //run callback in Router.svelte\r\n    cb({ layouts, route })\r\n  }\r\n\r\n  function click(event) {\r\n    const el = event.target.closest('a')\r\n    const href = el && el.getAttribute('href')\r\n\r\n    if (\r\n      event.ctrlKey ||\r\n      event.metaKey ||\r\n      event.altKey ||\r\n      event.shiftKey ||\r\n      event.button ||\r\n      event.defaultPrevented\r\n    )\r\n      return\r\n    if (!href || el.target || el.host !== location.host) return\r\n\r\n    event.preventDefault()\r\n    history.pushState({}, '', href)\r\n  }\r\n\r\n  return { updatePage, click }\r\n}\r\n\r\nfunction urlToRoute(url, routes) {\r\n  const route = routes.find(route => url.match(route.regex))\r\n  if (!route)\r\n    throw new Error(\r\n      `Route could not be found. Make sure ${url}.svelte or ${url}/index.svelte exists. A restart may be required.`\r\n    )\r\n\r\n  if (route.paramKeys) {\r\n    const layouts = layoutByPos(route.layouts)\r\n    const fragments = url.split('/').filter(Boolean)\r\n    const routeProps = getRouteProps(route.path)\r\n\r\n    routeProps.forEach((prop, i) => {\r\n      if (prop) {\r\n        route.params[prop] = fragments[i]\r\n        if (layouts[i]) layouts[i].param = { [prop]: fragments[i] }\r\n        else route.param = { [prop]: fragments[i] }\r\n      }\r\n    })\r\n  }\r\n\r\n  route.leftover = url.replace(new RegExp(route.regex), '')\r\n\r\n  return route\r\n}\r\n\r\nfunction layoutByPos(layouts) {\r\n  const arr = []\r\n  layouts.forEach(layout => {\r\n    arr[layout.path.split('/').filter(Boolean).length - 1] = layout\r\n  })\r\n  return arr\r\n}\r\n\r\nfunction getRouteProps(url) {\r\n  return url\r\n    .split('/')\r\n    .filter(Boolean)\r\n    .map(f => f.match(/\\:(.+)/))\r\n    .map(f => f && f[1])\r\n}\r\n","<script>\r\n  import { setContext } from 'svelte'\r\n  import { writable } from 'svelte/store'\r\n  import Route from './Route.svelte'\r\n  import init from './navigator.js'\r\n\r\n  export let routes\r\n\r\n  let layouts, route\r\n  const { updatePage, click } = init(\r\n    routes,\r\n    update => ({ layouts, route } = update)\r\n  )\r\n  updatePage()\r\n\r\n  setContext('routifyupdatepage', updatePage)\r\n\r\n  // svelte:window events doesn't work on refresh\r\n  ;['pushstate', 'popstate', 'replacestate'].forEach(e =>\r\n    addEventListener(e, () => updatePage())\r\n  )\r\n  addEventListener('click', click)\r\n</script>\r\n\r\n<Route {layouts} />\r\n"],"names":["subscriber_queue","writable","value","start","noop","stop","subscribers","set","new_value","safe_not_equal","run_queue","length","i","s","push","update","fn","subscribe","run","invalidate","subscriber","index","indexOf","splice","derived","stores","initial_value","single","Array","isArray","stores_array","auto","inited","values","pending","cleanup","sync","result","is_function","unsubscribers","map","store","run_all","url","listener","getContext","context","goto","_isActive","route","_url","path","keepIndex","currentPath","re","RegExp","match","_goto","params","_static","shallow","href","history","pushState","preserveIndex","replace","dir","forEach","Object","assign","key","entries","MATCH_PARAM","scrollAncestorsToTop","element","dataset","routify","scrollTo","parentElement","pathToRegex","str","recursive","suffix","pathToParams","string","matches","substr","pathToRank","isFallback","split","join","ctx","param","scopeToChild","component","layouts","scoped","setComponent","layout","$route","isActive","updateContext","setContext","remainingLayouts","el","routes","cb","eventName","state","title","event","Event","toLowerCase","apply","this","dispatchEvent","updatePage","currentUrl","window","location","pathname","urlToRoute","store.route","click","target","closest","getAttribute","ctrlKey","metaKey","altKey","shiftKey","button","defaultPrevented","host","preventDefault","find","regex","Error","paramKeys","arr","filter","Boolean","layoutByPos","fragments","f","getRouteProps","prop","[object Object]","leftover","init","e","addEventListener"],"mappings":"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"}